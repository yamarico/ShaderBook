= シェーダー言語とグラフィックAPI

前章でレンダーパイプラインの工程を理解しましたが、「具体的にどのようにシェーダーが実装されているのか？」という疑問が出てくるかと思います。本章では、シェーダーの具体的な実装について詳しく解説します。@<strong>{サーフェスシェーダーとフラグメントシェーダーの違い}、@<strong>{グラフィックスAPIとシェーダー言語}、各種@<strong>{グラフィックスエンジンとシェーダー}の関係、そして@<strong>{Unityを用いたシェーダープログラミングの始め方}について学びます。

== シェーダーの具体的な実装

シェーダーがレンダーパイプライン内でどのように実装されているのかを詳しく見ていきましょう。

=== サーフェスシェーダーとフラグメントシェーダーの違い

@<strong>{フラグメントシェーダー}は、各ピクセル（フラグメント）ごとに実行されるシェーダーで、最終的な色や深度を計算します。一方、@<strong>{サーフェスシェーダー}は、特定のゲームエンジン（例えばUnity）で提供される高レベルなシェーダー記述方式で、内部的にはバーテックスシェーダーとフラグメントシェーダーに分解されます。

@<strong>{フラグメントシェーダーの特徴}:
  * @<strong>{低レベル}での制御が可能。
  * 光の計算やテクスチャの適用など、ピクセル単位の操作ができる。
  * @<strong>{柔軟性が高い}が、その分@<strong>{複雑なコード}になることも。

* @<strong>{サーフェスシェーダーの特徴}（Unityの場合）:
  * @<strong>{高レベル}な記述が可能。
  * ライティングや影の計算をエンジンが自動的に処理。
  * @<strong>{コードが簡潔}になり、開発効率が向上。

* @<strong>{サーフェスシェーダーの利点}:
  * @<strong>{簡単に複雑なライティング}を実装できる。
  * エンジンの最適化を活用できる。
  * 初心者でも扱いやすい。

=== 実際の実装例
　* @<strong>{フラグメントシェーダー}では、光源や視線ベクトルを用いて手動で光の計算を行います。
　* @<strong>{サーフェスシェーダー}では、エンジンが用意した関数やライティングモデルを利用して、簡潔に記述できます。

=== バーテックスシェーダーとの連携

@<strong>{バーテックスシェーダー}は、頂点ごとに実行されるシェーダーで、頂点の位置や属性を計算します。バーテックスシェーダーとフラグメントシェーダーは連携して動作し、モデルの形状と見た目を決定します。

* @<strong>{バーテックスシェーダー}で頂点の変形や法線の計算を行う。
* @<strong>{フラグメントシェーダー}でピクセルの色やライティングを計算する。
* 二つのシェーダーが情報を受け渡し、最終的な描画結果を生成。

== グラフィックスAPIとシェーダー言語

シェーダーを実装するためには、@<strong>{グラフィックスAPI}とそれに対応する@<strong>{シェーダー言語}を理解する必要があります。ここでは、主要なグラフィックスAPIとシェーダー言語を紹介します。

=== OpenGLとGLSL

@<strong>{OpenGL}は、クロスプラットフォームなグラフィックスAPIで、Windows、macOS、Linux、モバイルデバイスなどで利用可能です。

* @<strong>{GLSL（OpenGL Shading Language）}は、OpenGLで使用されるシェーダー言語。
* @<strong>{C言語に似た構文}を持ち、ベクトルや行列の演算が簡単。
* クロスプラットフォームでの開発に適している。

=== HLSLとDirectX

@<strong>{DirectX}は、Microsoftが提供するWindows向けのマルチメディアAPIの集合で、特に@<strong>{Direct3D}がグラフィックス描画を担います。

* @<strong>{HLSL（High Level Shading Language）}は、DirectXで使用されるシェーダー言語。
* @<strong>{C言語に似た構文}で、GLSLと似た概念を持つ。
* Windowsプラットフォームでの開発に最適。

=== シェーダー言語の選び方

シェーダー言語の選択は、主に以下の要因によります。

* @<strong>{開発プラットフォーム}：WindowsであればDirectXとHLSL、クロスプラットフォームであればOpenGLとGLSL。
* @<strong>{使用するゲームエンジン}：UnityではHLSLベースのShaderLab、Unreal EngineではHLSL。
* @<strong>{プロジェクトの要件}：対応デバイスや必要なグラフィックス機能。

== グラフィックスエンジンとシェーダー

さまざまなグラフィックスエンジンにおけるシェーダーの扱い方を見てみましょう。

=== Unreal Engineでのシェーダー

@<strong>{Unreal Engine}は、高品質なグラフィックスを実現する強力なゲームエンジンです。

* @<strong>{マテリアルエディタ}：ノードベースでシェーダー（マテリアル）を作成。
* @<strong>{ブループリント}：コードを書かずに視覚的にロジックを構築。
* @<strong>{HLSL}を用いたカスタムシェーダーの記述も可能。

=== Blenderでのシェーダー

@<strong>{Blender}は、オープンソースの3D作成ソフトウェアです。

* @<strong>{ノードエディタ}：マテリアルやシェーダーをノードで視覚的に作成。
* @<strong>{Pythonスクリプト}：カスタム処理や自動化に利用。
* @<strong>{Eevee}と@<strong>{Cycles}という二つのレンダリングエンジンを持つ。

=== Mayaでのシェーダー

@<strong>{Maya}は、プロフェッショナル向けの3Dアニメーションソフトウェアです。

* @<strong>{Hypershade}：シェーダーやマテリアルを視覚的に編集。
* @<strong>{MELスクリプト}や@<strong>{Python}でカスタムツールやシェーダーを開発。
* 映画やアニメーション制作で広く使用。

== Unityで始めるシェーダープログラミング

@<strong>{Unity}は、初心者からプロまで幅広く利用されているゲームエンジンです。ここでは、Unityを用いたシェーダープログラミングの始め方を詳しく解説します。

=== Unityの概要とレンダリング機能

@<strong>{Unityの特徴}：

* @<strong>{クロスプラットフォーム開発}：PC、モバイル、コンソール、VR/ARなど幅広いデバイスに対応。
* @<strong>{使いやすいエディタ}：直感的な操作でシーンの構築やオブジェクトの配置が可能。
* @<strong>{豊富なアセットストア}：モデル、テクスチャ、スクリプトなど多数のアセットが利用可能。

=== Unityのレンダーパイプライン

Unityでは、複数のレンダーパイプラインが提供されており、プロジェクトの要件に応じて選択できます。

=== ビルトイン、URP、HDRPの違い

* @<strong>{ビルトインレンダーパイプライン}：Unityの従
